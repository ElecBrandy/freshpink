+++
title = '[42cursus] netpractice'
date = 2024-08-15
featured_image = "http://t1.daumcdn.net/cfile/146F1B10ACE3228B52"
tags = ['C', '42cursus']
+++

> This document is a System Administration related exercise.

<br>

# 소개
____
<img src="https://i.imgur.com/UCUbHvr.png" width="700">

42서울 본과정 입과 후 n번째로 수행한 과제로, 교육 인터페이스상에서 소규모 네트워크를 구성하는 과제이다. 네트워킹 문제를 해결하여 네트워크가 실행되도록 만들어야 한다. 총 10개의 문제를 완료하고, Git 저장소에 제출하는 것이 최종 목표이다.

<br>
<br>

# 개념 정리
___
## 네트워크란?
네트워크는 두 대 이상의 컴퓨터 시스템이 서로 연결되어 데이터를 교환할 수 있는 구조를 의미한다. 이 연결은 다양한 방법으로 이루어질 수 있으며, 물리적 케이블, 무선 신호, 또는 혼합된 방식으로 네트워크를 구성할 수 있다.

<br>

## 네트워크의 구성요소
### 서버
네트워크에서 데이터를 저장하고, 관리하며, 이를 클라이언트에게 제공하는 역할을 수행한다. 예를 들어, 파일 서버는 파일을 저장하고 이를 필요로 하는 클라이언트에 제공하는 역할을 수행한다.

### 클라이언트
클라이언트는 서버에 요청을 보내고, 서버로부터 데이터를 수신하는 장치로, 클라이언트는 개인용 컴퓨터, 스마트폰, 태블릿 등이 될 수 있다.

### 라우터 (Router)
라우터는 네트워크 간에 데이터 패킷을 전송하는 장치로, 라우터는 IP 주소를 기반으로 데이터를 목적지까지 전달하며, 인터넷 연결에서 중요한 역할을 한다.

### 스위치
동일한 네트워크 내에서 장치 간에 데이터를 전송하는 장치로, 각 장치의 MAC 주소를 기반으로 데이터를 올바른 장치로 전달한다.

### 호스트
네트워크에서 **호스트**는 네트워크에 연결된 모든 장치를 의미하며, 여기에는 서버, 데스크탑 컴퓨터, 노트북, 스마트폰 등이 포함된다.

<br>
<br>

## 네트워크 통신 과정
네트워크 통신을 위해서 **패킷**이라는 데이터 전송 단위를 만들어서 사용하며, 이를 만들거나 해석할 때에는 **TCP/IP** 모델을 사용한다. **TCP/IP** 모델은 기존의 **OSI 7계층 모델**을 간결화시킨 모델이고, 현대 대부분의 네트워크 통신의 기반이 되고 있다.

네트워크 통신에는 송신자와 수신자가 존재하며, 송신자는 패킷을 만들어 수신자에게 전송한다. 이때 송신자가 패킷을 송신할 때는 통신 모델의 최상위 계층부터 순차적으로 만들고, 수신자가 패킷을 수신할 때는 통신 모델의 최하위 계층부터 순차적으로 해석한다.

각 계층의 프로세스가 직접 통신하는 형태를 보이지만, 실제로는 항상 물리 계층을 통해 데이터가 전송된다.

일반 사용자는 전송해야 하는 데이터가 있으면 이를 응용 프로그램 계층에 보내 전송을 요청한다(송신 호스트). 응용 프로그램 계층은 원 데이터에 자신의 프로토콜에서 정의한 헤더 정보를 추가한다. 밑으로 내려가면서 각 계층 또한 이하 동문으로 헤더 정보를 추가한다. 수신 호스트에서는 계층별로 올라오면서 추가되어있는 헤더를 해석하고 처리하고, 최종적으로 원 데이터를 수신받을 수 있다.

<br>
<br>

## 프로토콜
네트워크에서 통신이 이루어지기 위한 규칙과 절차를 의미한다. 네트워크에서 두 개 이상의 장치가 데이터를 주고받기 위해서는 서로가 데이터를 어떻게 보낼지, 받을지, 해석할지에 대한 공통의 약속이 필요하며 그것이 바로 프로토콜임! 약속이자 규정으로 생각하자. 예를 들어 데이터가 전송되는 방법, 오류가 검출되고 수정되는 방법, 데이터를 조각내어 전송한 후 조합하는 방법 등등. TCP/IP, HTTP 모두 널리 알려진 프로토콜의 일종이다.

<br>
<br>

## OSI 7계층 모델
<img src="https://www.freecodecamp.org/news/content/images/2021/10/osi-vs-tcpip-1.png" width="700">

OSI(Open Systems Interconnextion) 모델은 네트워크 통신을 계층적으로 나누어 설명하는 표준화된 모델이다. 이는 통신 시스템의 다양한 기능을 7개의 계층으로 나누어 설명하며 네트워크 설계 및 문제 해결을 용이하게 한다. 현대 인터넷에서는 OSI 모델을 엄격하게 따르고 있지는 않지만, 이러한 유형의 구분은 네트워크 문제를 해결하는 데 유용하다. 사용자와 가장 가까운 응용 프로그램 계층부터 알아보자!

<br>

### 7. 응용 프로그램 계층 : Application Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2rcDKpr4WLqoyAZ7GDKkyJ/7cab96402de7ac5465b86e617da3da4e/osi_model_application_layer_7.png" width="700">

응용 프로그램 계층은 사용자와 직접 상호작용하는 유일한 계층으로, 사용자가 네트워크에 접근하고 데이터를 주고받을 수 있는 인터페이스를 제공한다. 이는 웹 브라우저, 이메일 클라이언트, 파일 전송 애플리케이션 등 다양한 형태로 구현된다.  

주의해야 할 점은 클라이언트 소프트웨어 애플리케이션과 응용 프로그램(애플리케이션) 계층은 다른 개념이라는 것이다. 실제 소프트웨어 애플리케이션은 사용자가 직접 상호작용하는 도구(웹 브라우저, 이메일 클라이언트 등의 인터페이스)이고, 애플리케이션 계층은 클라이언트 애플리케이션이 통신을 수행할 수 있도록 지원하는 네트워크 계층이다.  

응용 프로그램 프로토콜에는 HTTP, SMTP, DNS, FTP 등이 존재한다.

<br>

### 6. 프레젠테이션 계층 : The Presetation Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/19L86neKKT8srUkOSe4rf7/ff4c91c94a1790651df7b48433913f59/osi_model_presentation_layer_6.png" width="700">

프레젠테이션 계층은 응용 프로그램 계층과 직접 상호작용하며, 응용 프로그램이 데이터를 올바르게 해석하고 표시할 수 있도록 데이터를 준비하는 역할을 수행한다.  

프레젠테이션 계층은 **데이터의 변환**을 통해 송신자와 수신자가 서로 다른 데이터 형식을 사용하더라도 통신이 가능하게 한다. 예를 들어 텍스트 데이터를 `ASCII`에서 `Unicode`로 변환하거나 그 반대를 수행한다.  

장치가 암호화된 연결을 통해 통신하는 경우, 송신 측에서 데이터를 **암호화**하고 수신 측에서 **복호화**하는 과정을 통해 데이터가 안전하게 전송될 수 있게 한다.  

또한 응용 프로그램 계층(7)에서 수신한 데이터를 다음 세션 계층(5)으로 전송하기 전에 압축하는 일도 담당한다. 전송하는 데이터양을 줄임으로써 통신의 속도와 효율이 높아진다.  

<br>

### 5. 세션 계층 : The Session Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/29mRrgK22AqJVlg2MMlD86/34d8f4071b6cc0d3b03c93f55e4d89b7/osi_model_session_layer_5.png" width="700">

세션 계층은 통신 세션의 설정, 관리 그리고 종료를 담당한다. 이때 통신이 시작될 때부터 종료될 때까지의 시간을 세션이라고 하며, 세션 계층은 교환되고 있는 모든 데이터를 전송할 수 있도록 충분히 오랫동안 세션을 개방한 다음 리소스를 낭비하지 않기 위해 세션을 즉시 닫을 수 있게 한다. 즉, 송신자와 수신자 간의 대화를 관리하고 데이터 교환이 원활하게 이루어질 수 있도록 돕는 역할을 수행한다.  

세션 계층은 데이터 전송 과정에서 체크포인트를 사용한다. 예를 들어 100mb의 파일이 전송되는 경우 세션 계층이 5mb 체크포인트를 설정할 수 있다. 이때 62mb가 전송된 후 연결이 끊어지거나 충돌이 발생하면 마지막 체크 포인트에서 세션을 재개할 수 있다. 즉, 40mb의 데이터만 더 전송하면 된다.  

세션 계층은 세션 ID를 통해 각 세션을 고유하게 식별하며 추적하고 관리한다.  

세션 프로토콜에는 RPC, PPTP 등이 존재한다.  

<br>

### 4. 전송 계층 : Transport Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3OlO75NcADGL3SmEADFDqd/723b8c7639c4e2e6b4febcbe7fd36e0e/osi_model_transport_layer_4.png" width="700">

전송 계층은 두 기기 간의 종단 간 통신을 담당하며, 데이터를 가져와 **세그먼트**라는 조각으로 분할하는 역할을 수행한다. 이를 통해 **신뢰성 있는 전송**을 보장하는 것에 중점을 둔다. 또한 전송 계층은 컴퓨터 내부에서 논리적으로 구축되는 통신 당사자인 프로세스 사이의 통신 문제를 다룬다. 예를 들면 통화자 사이에 통화 연결을 설정하는 역할을 하는 것! 전송 계층 하위에 있는 물리 / 데이터 링크 / 네트워크 계층은 전송계층의 연결을 설정하고 어떻게 활용할지 다루는 것  뿐이다.  

전송 계층은 흐름제어 및 오류 제어 기능의 역할도 수행하지만, 네트워크 간 통신에 대해서만 작동한다.  

전송 계층 프로토콜에는 TCP(전송 제어 프로토콜), UDP(사용자 데이터그램 프로토콜)이 존재한다.  

<br>

### 3. 네트워크 계층 : The Network Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3g2Hv0frHsql5SFauJL5EG/d8cede7b6a780e63413bd86de9eee7f9/osi_model_network_layer_3.png" width="700">

네트워크 계층은 서로 다른 두 네트워크 간 데이터 전송을 용이하게 하며 라우팅, IP 주소 관리, 패킷 포워딩 등의 기능을 수행한다. 이때 서로 통신하는 두 장치가 동일한 네트워크에 있는 경우에는 네트워크 계층이 필요하지 않음!

네트워크 계층의 중요한 기능 중 하나는 **라우팅**이다. **라우팅**은 데이터 패킷이 출발지에서 목적지까지 가는 최적의 물리적 경로를 결정하는 과정으로, 네트워크 계층은 여러 네트워크를 통과하는 경로를 설정하며 각 패킷을 올바른 경로로 전달한다.

네트워크 계층은 데이터를 패킷 단위로 처리한다. 패킷은 목적지 IP 주소를 포함하고 있으며, 이를 기반으로 데이터를 목적지까지 포워딩(전달)한다.

네트워크 계층 프로토콜에는 IP, ICMP, IGMP, 그리고 장비로는 라우터 등이 존재한다.

<br>

### 2. 데이터 연결 계층 : The Data Link Layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3TLHavXiotb9ayyZFKECf3/9456d1c431cd71ceea7f4b407f076f11/data_link_layer_osi_model.png" width="700">

상위 계층에서 전달받은 데이터를 받아 Frame(물리 계층을 통해 전송할 수 있는 데이터 패킷)으로 나누고, 각 프레임에는 시작과 끝을 알리는 특정 비트 패턴과 제어 정보를 포함하여 데이터의 구분/무결성을 유지한다. 주로 CRC(Cyclic Redundancy Chec : 패리티 비트 또는 체크섬 방식 등)을 사용한다.

프레임을 전송할 때 각 네트워크 인터페이스에 할당된 고유의 물리적 주소인 MAC 주소를 사용한다.

데이터 연결 계층은 또한 인트라 네트워크 통신에서 **흐름 제어** 및 **오류 제어**를 담당한다. **오류 제어**에서 오류 검출 기능은 수행하지만, 오류 수정은 또 다른 문제... 발견된 오류는 상위 계층에서 수정되거나 재전송을 요구할 수 있다. **흐름 제어**를 통해 송신자와 수신자의 데이터 처리 속도가 다를 경우 문제를 제어하며 결과적으로 데이터가 수신자에게 너무 빠르게 전달되어 버퍼 오퍼플로우가 발생하는 것을 막는다.

네트워크 인터페이스 카드, 스위치, 브리지 등이 존재한다.

<br>

### 1. 물리 계층 : The physical layer
<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1HQ1W5P4XAinIdM37DTu4U/900ccdceda346baf03ce8b9f977d2974/osi_model_physical_layer_1.png" width="700">

상위 계층에서 전달된 데이터를 물리적 매체를 통해 전송할 수 있는 형태(Bit 형태)로 변환하여 전송한다. 즉, 데이터를 비트 스트림으로 나누어 전송하고, 수신 측에서 다시 원래 데이터로 재조립하는 것!

단순히 데이터를 전달하는 역할만 수행하며, 내용은 관여하지 않는다. 에러 검출이나 신뢰성에 대해 무관심하고 알 수도 없다.

네트워크 어댑터, 리피터와 허브, 케이블, 커넥터 등이 존재한다.

<br>
<br>

## TCP/IP 모델
<img src="https://www.freecodecamp.org/news/content/images/2021/10/osi-vs-tcpip-1.png" width="700">

TCP/IP란 TCP 및 IP라 불리는 프로토콜을 중심으로 구성되는 일련의 프로토콜들의 총칭이다. 일반적으로 TCP/IP 프로토콜이라 하면, TCP와 IP뿐만 아니라 관련된 프로토콜 집단을 의미한다.  

TCP/IP 모델은 OSI 모델과 유사하게 네트워크 통신을 계층화하여 설명하는 모델이지만, 더 간소화된 구조를 가지고 있다. 실질적으로 인터넷의 기반이 되는 프로토콜 스택으로, 각각의 계층은 특정한 기능을 담당한다. 아래는 TCP/IP 모델의 주요 프로토콜 간의 상호작용을 나타내고 있다.  

<br>

<img src = "https://i.imgur.com/1ARBFjM.png" width = "700">

<br>

### 응용 계층 : Application Layer
응용 계층은 TCP/IP 모델에서 사용자와 가장 가까운 계층으로, 응용 프로그램이 네트워크와 상호작용하는 인터페이스를 제공한다. 이 계층은 OSI 모델의 **응용 프로그램 계층, 프레젠테이션 계층, 세션 계층**의 기능을 통합하고 있다.

주요 프로토콜으로 HTTP, FTP, SMTP, DNS, TELNET, SNMP 등이 있으며, 이들 프로토콜은 웹 서비스, 파일 전송, 이메일, 도메인 이름 해석 등 다양한 네트워크 서비스를 제공한다. 예를 들면, 사용자가 웹 브라우저를 통해 웹 페이지를 요청할 때 HTTP 프로토콜을 사용하여 요청을 처리하고 서버에서 페이지를 받아온다.

<br>

### 전송 계층 : Transport Layer
전송 계층은 데이터를 작은 조각으로 나누어 송신자와 수신자 간에 신뢰성 있는 데이터 전송을 보장한다. 이 계층은 데이터 전송의 신뢰성을 확보하고, 데이터의 순서와 무결성을 관리한다.  

주요 프로토콜에는 TCP와 UDP가 존재하며, TCP는 연결 지향적 프로토콜로, 데이터의 순서와 신뢰성을 보장하고 UDP는 비연결 지향적 프로토콜로, 빠른 전송이 필요할 때 사용되며, 신뢰성은 보장하지 않는다.  

예를 들면, TCP를 사용하는 웹 브라우징에서는 데이터가 올바르게 도착할 때까지 확인 응답(ACK)을 통해 전송이 보장된다. UDP를 사용하는 스트리밍 서비스에서는 데이터 전송 속도가 우선시된다.  

<br>

### 인터넷 계층 : Internet Layer
인터넷 계층은 패킷이 출발지에서 목적지까지 이동할 수 있도록 경로를 결정하는 역할을 한다. 이 계층은 OSI 모델의 네트워크 계층과 유사한 역할을 수행하며, IP 주소를 사용하여 패킷을 라우팅한다.

주요 프로토콜에는 IP(Internet Protocol), ICMP(Internet Control Message Protocol), ARP(Address Resolution Protocol), RIP(Routing Information Protocol) 등이 존재한다.
- IP는 인터넷에서 패킷을 전달하는 핵심 프로토콜로, 주소 지정과 라우팅을 담당한다.
- ICMP는 네트워크 상태를 진단하고, 오류 메시지를 전달하는 데 사용된다.
- ARP는 IP 주소를 MAC 주소로 변환하여, 로컬 네트워크에서 데이터가 올바른 물리적 주소로 전달될 수 있게 한다.
- RIP는 라우터 간 라우팅 정보를 교환하여, 최단 경로를 결정하고 데이터 전송을 최적화하는 데 사용된다.

<br>

### 네트워크 인터페이스 계층 : Network Interface Layer
네트워크 인터페이스 계층(또는 링크 계층, 네트워크 접근 계층)은 물리적 네트워크 하드웨어와 데이터를 송수신하는 데 필요한 모든 것을 처리한다. 이 계층은 OSI 모델의 물리 계층과 데이터 링크 계층의 기능을 통합한 역할을 수행한다.

주요 프로토콜에는 이더넷, Wi-Fi, PPP(Point-to-Point Protocol), ARP 등이 존재한다. 예를 들면, 이더넷 케이블을 통해 컴퓨터와 라우터가 연결될 때, 이 계층에서 데이터가 전기 신호로 변환되어 전송된다. Wi-Fi를 통해 무선으로 데이터가 전송될 때도 이 계층이 작동한다.

<br>
<br>

## IP
IP는 Internet Protocol로 TCP/IP 모델의 인터넷 계층에서 사용되는 프로토콜이다. 네트워크에 존재하는 각 장비들을 식별하기 위한 논리주소이며 모든 장비는 IP 주소를 통해 출발지와 목적지를 식별하여 패킷을 주고받는다. 현재 IP 주소는 주로 IPv4와 IPv6 두 가지 버전이 사용된다.  

인터넷의 성장에 따라 IPv4에 할당할 수 있는 주소 공간이 부족해지자 더 넓은 주소 공간을 제공하는 IPv6가 도입되었다.  

### IPv4
<img src="https://i.imgur.com/X1c2YZn.png" width="700">

IPv4 주소는 32비트 길이로 구성되며 이 비트는 2^32개의 고유한 주소를 만들 수 있다.

클래스 기반의 IP 주소체계인 클래스 풀에 따르면 IPv4 주소는 A, B, C, D, E 클래스로 나뉜다. 현재는 클래스 개념 없이 사용하긴 한다. (Classes)

<details>
<summary>Classes 구분</summary>
<div markdown="1">

#### 클래스 A
- 대규모 네트워크 (`1.0.0.0` ~ `127.255.255.255`)
- 첫번째 Octet은 네트워크, 나머지 호스트   

#### 클래스 B
- 중규모 네트워크 (`128.0.0.0` ~ `191.255.255.255`)
- 첫번째-두번째 Octet은 네트워크, 나머지 호스트   

#### 클래스 C
- 소규모 네트워크 (`192.0.0.0` ~ `223.255.255.255`)
- 첫번째-두번째-세번째 Octet은 네트워크, 나머지 호스트   

#### 클래스 D
- 멀티캐스트 (`224.0.0.0` ~ `239.255.255.255`)   

#### 클래스 E
- 예약용 (`240.0.0.0` ~ `255.255.255.255`)   

</div>
</details>

IPv4 주소는 총 4개의 Octet으로 나뉘는데, 각 Octet은 8비트로 구성된다.
- 첫번째 Octet : 네트워크 클래스 및 네트워크 식별자
- 두번째 Octet : 네트워크 내 서브넷 구분
- 새번째 Octet : 네트워크 내 서브넷 구분
- 네번째 Octet : 호스트 식별자로, 해당 네트워크 내 특정 장치 식별

<br>

### IPv6
<img src="https://i.imgur.com/Fc3YAgp.png" width="700">

IPv6 주소는 128비트 길이로 구성되며 2^128개의 고유한 주소를 만들 수 있다. IPv6는 기본적으로 더 많은 주소 공간을 제공하며, IPsec을 통해 보안을 기본적으로 통합하고 호스트가 네트워크에 연결되었을 때 자동으로 주소를 구성할 수 있도록 설계되었다.

IPv6 주소는 총 8개의 16비트 블록으로 나뉘는데, 각 Octet은 8비트로 구성된다.
- 첫 번째 블록 : 전역 라우팅 접두사로, 인터넷 상에서의 위치를 나타냄
- 중간 블록 : 서브넷 ID 또는 서브넷 구분
- 마지막 블록 : 인터페이스 식별자로, 해당 서브넷 내 특정 장치 식별

<br>

## 서브넷
서브넷은 큰 네트워크를 더 작은 네트워크로 나눈 것을 의미한다. 서브넷을 통해 네트워크를 효율적으로 관리하고 자원을 최적화할 수 있다. 예를 들어 42회사에 하나의 큰 네트워크가 있다고 가정하자. 이 네트워크를 서브넷으로 나누면 (IT 부서, 영업 부서, 관리 부서 등) 각 부서가 독립적인 네트워크를 사용할 수 있다.

<br>

## 서브넷 마스크
서브넷 마스크는 IP주소를 네트워크 부분과 호스트부분으로 구분하는데 사용한다. 서브넷 마스크를 통해 비로소 네트워크를 더 작은 서브넷으로 나눌 수 있다.

<br>

## 스위치의 기능과 데이터 처리 방법
**스위치**는 네트워크의 장치들을 연결하는 장비로 데이터 링크 계층(2)에서 동작하며, **동일한 네트워크** 내에서 데이터 패킷을 전달한다. 스위치는 `MAC` 주소를 기반으로 데이터를 처리하고 전송하는데, `MAC` 주소 테이블을 통해 각 포트에 연결된 장치들의 `MAC` 주소를 학습하여 데이터를 적잘한 장치로 전송한다.

<br>

## 라우터의 기능과 데이터 처리 방법
**라우터**는 서로 다른 네트워크를 연결하는 장비로, 네트워크 계층(3)에서 동작하며, 라우터는 네트워크의 경로를 설정하고 최적의 경로로 패킷을 전송하는 기능을 담당한다. 라우터는 데이터 패킷의 헤더를 분석하여 목적이 `IP` 주소를 확인하고, 라우팅 테이블을 참조하여 패킷을 어느 네트워크로 보내야 할지를 결정한다. 때문에 라우터는 서로 다른 서브넷 간의 통신을 가능하게 한다.

<br>

## 정적 라우팅과 동적 라우팅?
정적 라우팅과 동적 라우팅은 네트워크에서 패킷을 전달하는 경로를 설정하는 두 가지 주요 방법이다!
| 구분 | / 정적 라우팅 | / 동적 라우팅 |
| --- | --- | --- |
| 설정방식 | / 수동으로 경로를 설정 | / 라우터가 자동으로 경로를 설정 |
| 변경관리 | / 네트워크 변화 시 수동으로 경로 갱신 필요 | / 네트워크 변화에 자동으로 적응 |
| 안정성 | / 매우 안정적, 예측 가능하지만 유연성이 부족 | / 유연하고 장애 복구가 자동으로 이루어짐 |
| 리소스 사용 | / 적은 리소스 사용 | / CPU, 메모리, 대역폭 등 리소스 소비 증가 |
| 복잡성 | / 소규모 네트워크에서 단순하고 관리가 용이 | / 대규모 네트워크에서 유리 하나 설정과 관리가 복잡 |
| 적용 대상 | / 소규모, 변화가 적은 네트워크 | / 대규모, 변화가 많은 네트워크 |

<br>

## 라우터의 패킷 처리 방식
1. **패킷 수신**
우선 라우터는 네트워크 포트로 들어오는 데이터 패킷을 수신한다. 이 패킷에는 목적지 `IP` 주소가 포함되어 있다.

2. **라우팅 테이블 조회**
라우터는 라우팅 테이블에 의거하여 패킷을 어디로 보낼지 결정한다. 이때 여러 경로가 가능하다면 주로 최단 경로 또는 비용 효율적인 경로를 선택한다고 한다.

3. **패킷 전송**
라우터는 선택한 경로에 따라 패킷을 다음 **홉**(패킷이 네트워크를 통해 목적지로 가능 동안 거치는 중간 라우터나 네트워크 장치)으로 전송한다. 다음 홉은 뭐... 최종 목적지일 수도 있고, 다른 라우터일 수도 있다.

4. **TTL 관리**
패킷이 여러 라우터를 거치는 과정에서 무한히 경로를 순환하지 않도록 라우터는 TTL(Time to Live)를 관리한다. 패킷이 라우터를 통과할 때마다 TTL 값이 감소하며, TTL 값이 0이 되면 패킷은 폐기된다.

<br>

## 0.0.0.0/0, default의 정체
그렇다면 과제에 나오는 의문의 범위... `0.0.0.0/0`과 default의 정체는 무엇일까?

정적 라우팅에서 `0.0.0.0/0`이 설정된 경우, 이 경로는 기본 경로(default)로 사용된다. 보통 내부 네트워크에서 목적지가 명확하지 않은 모든 트래픽을 ISP의 게이트웨이로 보내기 위해 기본 경로를 설정한다.

<br>

# Mandatory
____

<details>
<summary>LEVEL_01</summary>
<div markdown="1">

<img src="https://i.imgur.com/dlxEmX1.png" width="600">

**client A** 와 **client B**를 연결해보자. 서브넷 마스크 `255.255.255.0`는 CIDR 표기법으로 `/24`와 동일하다. 즉 네트워크를 표현하기위해 왼쪽부터 24자리, 나머지 8자리는 호스트를 표현하기 위해 사용한다는 의미이다.

IP 주소와 서브넷 마스크를 AND 연산하여 네트워크 ID `104.94.23.0` 를 얻을 수 있다. 브로드캐스트 주소는 네트워크 ID에서 호스트 부분의 모든 비트를 1로 설정한 상태이므로 `104.94.23.255` 임을 알 수 있다.

그렇다면 **client A** 의 IP 주소를 `104.94.23.1` ~ `104.94.23.254` 사이로 설정하면 해결! D와 C도 같은 방법으로 풀이하면 된다.
</div>
</details>

<br>

<details>
<summary>LEVEL_02</summary>
<div markdown="1">

<img src="https://i.imgur.com/KU0QtmC.png" width="600">

**client A** 와 **client B**를 연결해보자. 우선 둘의 서브넷 마스크를 `255.255.255.224` 하나로 통일해주자. 서브넷 마스크 `255.255.255.224`는 CIDR 표기법으로 `/27`와 동일하다. 즉 네트워크를 표현하기위해 왼쪽부터 27자리, 나머지 5자리는 호스트를 표현하기 위해 사용한다는 의미이다.

B의 IP 주소와 서브넷 마스크를 AND 연산하여 네트워크 ID `192.168.134.192` ()를 얻을 수 있다. 브로드캐스트 주소는 네트워크 ID에서 호스트 부분의 모든 비트를 1로 설정한 상태이므로 `104.94.23.223` 임을 알 수 있다.

**네트워크 ID**
- `192.168.134.192`
- `11000000.10101000.10000110.11000000` (2)
**브로드캐스트 주소**
- `192.168.134.223`
- `11000000.10101000.10000110.11011111` (2)

그렇다면 **client A** 의 IP 주소를 `192.168.134.193` ~ `192.168.134.222` 사이로 설정하면 해결(B와 겹치지 않게)! D와 C도 같은 방법으로 풀이하면 된다.
</div>
</details>

<br>

<details>
<summary>LEVEL_03</summary>
<div markdown="1">

<img src="https://i.imgur.com/y97WZDM.png" width="600">

> Goal 1 : Host A need to communicate with Host B
> Goal 2 : Host A need to communicate with Host C
> Goal 3 : Host B need to communicate with Host C

우선 같은 스위치에 연결된 기기들의 서브넷 마스크를 `255.255.255.128`으로 통일시켜주자. 서브넷 마스크 `255.255.255.128`는 CIDR 표기법으로 `/25`와 동일하다. 즉 네트워크를 표현하기위해 왼쪽부터 25자리, 나머지 7자리는 호스트를 표현하기 위해 사용한다는 의미이다.

A의 IP 주소가 고정되어 있으므로, A의 IP 주소와 서브넷 마스크를 AND 연산하여 네트워크 ID `104.198.91.0` ()를 얻을 수 있다. 브로드캐스트 주소는 네트워크 ID에서 호스트 부분의 모든 비트를 1로 설정한 상태이므로 `104.198.91.127` 임을 알 수 있다.

그렇다면 **client A** 의 IP 주소를 `104.198.91.1` ~ `104.198.91.126` 사이로 설정하면 해결(겹치지 않게)! 모두 같은 서브 네트워크에 속해있기 때문에, 각각 IP 주소를 `104.198.91.1` ~ `104.198.91.126` 사이로 설정하면 된다.

</div>
</details>

<br>

<details>
<summary>LEVEL_04</summary>
<div markdown="1">

<img src="https://i.imgur.com/rKWwPb1.png" width="600">

> Goal 1 : A nice host need to communicate with Another host
> Goal 2 : A nice host need to communicate with My_Gate
> Goal 3 : Another host need to communicate with My_Gate

우선 같은 라우터에 연결된 서브넷 범위와 서브넷 마스크는 상이해야함으로 겹치지 않게 R1을 조정해주자. 들의 서브넷 마스크를 `255.255.255.0` 정도로 통일시켜주자. 서브넷 마스크 `255.255.255.0`는 CIDR 표기법으로 `/24`와 동일하다. 즉 네트워크를 표현하기위해 왼쪽부터 24자리, 나머지 8자리는 호스트를 표현하기 위해 사용한다는 의미이다.

A의 IP 주소가 고정되어 있으므로, A의 IP 주소와 서브넷 마스크를 AND 연산하여 네트워크 ID `123.66.113.128`를 얻을 수 있다. 브로드캐스트 주소는 네트워크 ID에서 호스트 부분의 모든 비트를 1로 설정한 상태이므로 `123.66.113.255` 임을 알 수 있다.

그렇다면 **client A** 의 IP 주소를 `123.66.113.129` ~ `123.66.113.254` 사이로 설정하면 해결(겹치지 않게)! 모두 같은 서브 네트워크에 속해있기 때문에, 각각 IP 주소를 `104.198.91.1` ~ `104.198.91.126` 사이로 설정하면 된다.

</div>
</details>

<br>

<details>
<summary>LEVEL_05</summary>
<div markdown="1">

<img src="https://i.imgur.com/rQ3XDDw.png" width="600">

> Goal 1 : Machine A need to communicate with The Mighty Router
> Goal 2 : Machine B need to communicate with The Mighty Router
> Goal 3 : Machine A need to communicate with Machine B

라우터가 서로 다른 서브넷을 연결하고 있는 상황이다. 즉 A와 B는 별개의 서브넷에 속하고 있다. 라우터 인터페이스에 따라 각각의 서브넷 마스크를 통일하고, 범위에 맞는 IP를 넣어주자.

`client A: Machine A Routes :` 이 부분은 A의 서브넷 범위 밖으로 데이터를 전달하고 싶을때, A는 해당 위치가 어디있는지 모르기 때문에 라우터에게 라우팅을 일임하는 것이다. 왼쪽 박스에는 `default`(본인의 범위 제외하고 다를 의미), 오른쪽 박스에는 라우팅을 일임할 라우터의 인터페이스 IP 주소를 적는다.

A가 속한 서브넷을 벗어나는 트래픽(외부 네트워크로 가는 트래픽)에 대해, 클라이언트 A는 그 목적지가 어디 있는지 모른다! 따라서 이러한 모든 트래픽을 처리하기 위해 라우터의 특정 인터페이스로 트래픽을 전송하도록 설정된다. 이 경우, 라우터의 인터페이스 IP 주소가 기본 게이트웨이로 설정된다.

</div>
</details>

<br>

<details>
<summary>LEVEL_06</summary>
<div markdown="1">

## LEVEL_06
<img src="https://i.imgur.com/sQYZYIk.png" width="600">

> Goal 1 : Interface A1 need to communicate with interface Somewhere on the Net

LEVEL 06 부터 인터넷이 등장한다. 라우터와 A를 연결하자. R1과 A1의 서브넷 마스크를 통일하고, A1의 IP와 서브넷 마스크의 AND 연산을 통해 네트워크 ID가 `120.223.14.128`, 브로드케스트 주소가 `120.223.14.255` 임을 알 수 있다.

그렇다면 같은 서브넷 주소 범위를 공유하는 R1과 A의 IP 주소는 `120.223.14.129` ~ `120.223.14.254` 사이이어야 한다. 여기서 R1을 A와 겹치지 않게 설정해주자.  모두 같은 서브 네트워크에 속해있기 때문에, 각각 IP 주소를 `104.198.91.1` ~ `104.198.91.126` 사이로 설정하면 된다.

다음으로 인터넷을 설정해보자. 왼쪽 박스(실제로 보내려고 하는 서브넷 범위)에는 `120.223.14.226/25`처럼 A의 IP와 CIDR 표기를 함께 적어주어야 한다. 인터넷 입장에서는 A의 IP가 궁금한게 아니라 A가 속한 서브넷의 네트워크 ID가 필요하다. 인터넷에서 송신할 때에는 연결된 라우터나 네트워크가 상당히 많기 때문에 default로 퉁칠 수가 없다.

마지막으로 라우터를 설정해보자. 이때는 왼쪽 박스를 defualt 값으로 채워넣어도 무방하다.

</div>
</details>

<br>
<br>

# Reference
____

- https://www.cloudflare.com/ko-kr/learning/ddos/glossary/

- open-systems-interconnection-model-osi/

- https://www.geeksforgeeks.org/tcp-ip-model/

- http://www.ktword.co.kr/test/view/view.php?no=205\

- https://nordvpn.com/ko/blog/what-is-subnet-mask/

- https://80000coding.oopy.io/17d8f803-479c-4e67-ab77-0be44da1e6d4


<br>
{{<alert>}}
<a href="https://elecbrandy.github.io/tags/42cursus"> 42cursus </a>
{{</alert>}}
<br>

