+++
title = '[42cursus] philosopers'
date = 2024-08-05
featured_image = "http://t1.daumcdn.net/cfile/15110210A8445BF80D"
tags = ['C', '42cursus']
draft = true
+++

> **I never thought philosophy would be so deadly**
> Summary : In this project, you will learn the basics of 스레드ing a 프로세스. You will see how to create 스레드s and you will discover mutexes.

<br>

# 소개
____
<img src="https://i.imgur.com/QOMTZ7P.png" width="700">

42서울 본과정 입과 후 여섯번째로 수행한 과제로
철학자 문제를 통해 프로세스 스레딩의 기본, 스레드를 만드는 방법, 뮤텍스와 세마포어 등을 공부하는 과제이다.  

원탁이 하나 있고, 그 주변에 몇 명의 철학자들이 둘러앉아 있다. 원탁의 가운데에는 커다란 스파게티 보울이 놓여 있다. 철학자들은 배고플 때마다 양옆의 포크 두 개를 잡아야만 스파게티를 먹을 수 있으며, 포크를 내려놓고 다시 생각하기를 반복한다. 이를 통해 어떻게 하면 철학자들이 모두 굶지 않고 잘 먹을 수 있을지를 고민하는 문제!

<br>
<br>

# philosopher 명세서
____
## Overview
### 철학자, 원탁, 포크, 스파게티
- n명의 철학자들이 테이블에 둘러앉아 있다.
- 철학자 번호 `n`은 철학자 `n-1`과 `n+1`번 사이에 앉는다.
- 테이블 중앙에 커다란 스파게티 한 그릇이 놓여져 있다.
- 철학자들은 `먹기`, `생각하기`, `잠자기` 를 반복하며, 한번에 한가지 동작만 취할 수 있다.
- 테이블 위에는 철학자의 수와 같은 수의 포크가 있으며, 각 철학자 사이에 놓여있다.

### 스파게티를 먹는 규칙
- 철학자는 스파게티를 먹기 위해 오른손에 오른쪽 포크, 왼손에 왼쪽 포크를 들어야한다. (반드시 양손에 포크)
- 철학자가 스파게티 `먹기`를 마치면 포크를 테이블에 내려놓고 `잠자기` 상태가 되고, 잠에서 꺠어나면 `생각하기` 시작한다.
- 이 과정은 철학자가 굶어 죽을 때까지 계속된다.

### 철학자의 규칙
- 모든 철학자는 먹어야 하며, 굶어 죽어서는 안된다.
- 철학자들은 서로 대화하지 않으며, 다른 철학자가 죽을 것인지 알지 못한다.
- 철학자들은 **죽는 것을 피해야** 한다!

<br>

## Global Rules
- **PROTOTYPE**
	- `philosopher`
- **PARAMETER**
	- `number_of_philosophers`
		- 철학자의 수 (곧 포크의 수)
	- `time_to_die`
		- 철학자의 수명 (밀리초 단위)
		- **철학자는 죽는다!**
			- 철학자가 마지막으로 밥을 먹기 시작한 시점으로부터 `time_to_die` 시간만큼 지나거나
			- 프로그램 시작 후 `time_to_die` 시간만큼이 지나도록 식사를 시작하지 않는다면
	- `time_to_eat`
		- 철학자가 밥을 먹는데 걸리는 시간
		- 이 시간 동안 철학자는 양손에 포크를 하나씩 잡고 있어야 함
	- `time_to_sleep`
		- 철학자가 잠자는데 걸리는 시간 (밀리초 단위)
	- `number_of_times_each_philosopher_must_eat`
		- 각 철학자가 최소한 밥을 먹어야 하는 횟수
		- 모든 철학자가 이 횟수 만큼 밥을 먹으면 시뮬레이션 종료
		- 선택적 인자이며, 지정되지 않은 경우 철학자가 죽을 때 시뮬레이션 종료
- **PROGRAM_LOG**
	- 시뮬레이션은 철학자의 상태를 출력해야함
	- 철학자의 상태는 다른 철학자들의 상태와 뒤엉키거나 섞인 상태로 출력되면 안됨
	- 철학자의 사망 시점과 이를 출력하기 까지의 틈이 10ms 이상이 되면 안됨
	- 로그 출력
		- `timestamp_in_ms X has taken a fork`
		- `timestamp_in_ms X is eating`
		- `timestamp_in_ms X is sleeping`
		- `timestamp_in_ms X is thinking`
		- `timestamp_in_ms X died`
- **DESCRIPTION**
	- **Mandatory part**
		- 각 철학자는 스레드로 구현되어 있어야 함
		- 각 철학자 왼쪽과 오른쪽에 포크가 하나씩 존재해야 함
		- 철학자가 한 명일 경우 테이블 위에 포크가 하나만 존재해야 함
		- 철학자가 포크를 복제하는 것을 막기 위해서, 각 포크의 현재 상태를 뮤텍스를 이용하여 보호해주어야 함
	- **Bonus part**
		- 모든 포크는 테이블 가운데에 있음
		- 메모리의 상태는 알 수 없지만, 대신 사용가능한 포크의 수가 세마포어로 표현됨
		- 각 철학자는 프로세스로 이루어져 있어야 하고, 메인 프로세스가 철학자가 되어선 안 됨
		- 한번 호출하여 3, 4, 5 그 이후 다시 4, 5 등등을 읽을 수 있어야 함

<br>
<br>

# 개념 정리
___
## Mutex
상호 배제를 위한 도구로, 오직 하나의 스레드만 특정 코드 섹션이나 자원에 접근할 수 있도록 보장한다. `Mutex`는 **잠금**과 **해제** 동작을 통해 이를 구현함.  

> _화장실 문에는 자물쇠(뮤텍스)가 달려 있습니다. 어떤 사람이 화장실을 사용하려고 하면 자물쇠를 잠급니다. 다른 사람은 화장실이 잠겨있으므로 기다려야 합니다. 화장실을 사용한 사람이 나가면 자물쇠를 풀고 다음 사람이 들어갈 수 있습니다. 여기서 뮤텍스는 단 하나의 스레드(사람)만이 화장실(자원)에 접근하도록 보장합니다._

<br>

## Semaphore
여러 스레드(또는 프로세스)가 공유 자원에 접근하는 것을 조절하기 위한 동기화 도구이다. 내부적으로 카운터를 사용하며, 이 카운터 값에 따라 스레드들의 자원 접근 여부가 결정됨!  

> _당신이 카페에 있습니다. 이 카페에는 3개의 테이블이 있습니다. 카페의 문지기(세마포어)는 테이블이 다 차지 않는 한 사람들을 들여보냅니다. 만약 테이블이 다 차면 문지기는 더 이상 사람들을 들여보내지 않고 기다리게 합니다. 손님 중 한 명이 나가면 문지기는 대기 중인 손님 중 한 명을 들여보냅니다. 여기서 카운터 값은 현재 비어있는 테이블의 수입니다._

<br>

## Mutex vs Semaphore
공부하면서 느낀 점은, `Mutex`는 결국 단일 스레드의 영역을 전개함으로, 크기가 1인 `Semaphore`와 같지 않을까?
- **목적**
	- `Mutex`
		- 오로지 하나의 스레드만이 자원에 접근해야 할 때 사용
	- `Semaphore`
		- 여러 스레드가 접근할 수 있지만 최대 한도를 정하고 싶을 때 사용
		- 제한된 수의 자원을 관리할 때 사용
- **동작 방식**
	- `Mutex`
		- 잠금과 해제를 사용해 오직 하나의  스레드만 자원에 접근할 수 있도록 동작
	- `Semaphore`
		- 카운터를 사용하여 스레드의 접근을 조절하며, 카운터 값이 0이 되면 스레드들은 대기함
- **잠금과 해제**
	- `Mutex`
		- 단 하나의 잠금과 해제가 가능
	- `Semaphore`
		- 여러 개의 잠금과 해제가 가능

<br>

## Data race
두 개 이상의 스레드가 동시에 동일한 메모리 위치를 읽거나 쓸 때 발생하는 문제이며, 우리는 이번 과제에서 이를 방지해야만 한다. 최소 하나의 스레드가 쓰기 작업을 수행하고 있으며, 스레드 간의 실행 순서가 정의되지 않은 경우 발생할 수 있고 Data race는 결국 프로그램의 예측 불가능한 동작을 초래할 수 있다. 따라서 뮤텍스, 세마포어 등의 동기화 메커니즘을 사용하여 스레드 간의 자원 접근을 방지해야함!  

<br>

## Deadlock
두 개 이상의 스레드(또는 프로세스)가 서로 상대방이 점유하고 있는 자원을 기다리며 무한정 대기하는 상태로, 이로 인해 시스템이 멈추게 되고, 어떤 작업도 진행되지 않는 상황이 발생한다. **Deadlock**이 발생하기 위해서는 아래 네 가지 조건이 모두 만족되어야 하는데... 우리는 이 여러가지 조건 중 n개(아마 과제 조건 상 최대 2개가 가능하지 않을까?)을 파훼하여 **Deadlock** 발생을 피해야한다.

### Deadlock의 조건
#### 1. 상호 배제
- Mutual Exclusion
- 자원은 한번에 한 스레드만 사용할 수 있음
#### 2. 점유 대기
- Hold and Wait
- 자원을 점유한 상태에서 다른 자원을 기다림
#### 3. 비선점
- No Preemption
- 스레드가 자원을 강제로 빼앗기지 않으며, 스레드가 자원을 자발적으로 해제할 때까지 기다려야 함
#### 4. 순환 대기
- Circular Wait
- 스레드들이 순환 형태로 자원을 기다림
- 예를 들어, 스레드 A가 자원 1을 점유하고 자원 2를 기다리며, 스레드 B는 자원 2를 점유하고 자원 1을 기다리는 상황

<br>

## 프로세스
프로세스는 현재 실행 중인 프로그램으로, OS 관리의 단위이자 메모리에 로드되어 CPU에 실행되는 프로그램의 독립적인 실행 단위이다! 즉, 우리가 프로그램 A를 실행하면 A는 메인 메모리에 적재되며 하나의 프로세스로서 cpu 자원의 점유를 기다리게 된다. 각 프로세스는 자체의 주소 공간, 레지스터의 상태, file descriptor table, PCB 등 고유한 정보를 가진다.

이때 **PCB**란, Process Control Block을 의미하며 프로세스의 다양한 정보를 담고 있는 태그같은 것이다. 이는 OS가 프로세스 관리를 수행하는데 도움을 주며, 커널 영역에서 다뤄진다.  

<br>

## 프로세스의 상태
<img src="https://thebook.io/img/080367/028.jpg" width="700">

### 상태
- 생성 상태
  - 이제 막 메모리에 적재되어 PCB를 할당받은 상태
- 준비 상태
  - 스케줄링 큐이나, 반드시 선입선출 방식일 필요없음
  - CPU를 할당받을 준비가 되어있지만, 아직 차례를 기다리는 상태
  - 순서가 되면 실행 상태로 전환
- 실행 상태
  - CPU를 할당받아 실행 중인 상태
  - 할당된 시간 모두 사용 시 타이머 인터럽트 발생하며 준비 상태로 전환
- 대기 상태
  - 스케줄링 큐
  - 프로세스가 실행 상태 도중 입출력 장치를 사용하는 경우 대기 상태로 전환
  - 입출력 작업은 CPU에 비해 느리기 때문에 대기 상태에서 입출력 진행
  - 입출력이 끝나면 입출력 인터럽트 발생하며 준비 상태로 전환
- 종료 상태
  - 프로세스가 종료된 상태
  - PCB, 메모리 영역 등 자원 정리 및 회수

### 흐름
1. 프로세스 생성 : 새로운 프로세스가 생성되면 우선순위가 설정됨
2. 큐 배치 : 프로세스는 준비 큐 또는 대기 큐에 배치됨
3. 스케줄링 : 스케줄링 알고리즘이 준비 큐에서 프로세스를 선택하여 CPU를 할당함
4. 실행 : 선택된 프로세스가 CPU를 사용하여 작업을 수행함
5. 상태 전이 : 프로세스가 완료되거나 대기 상태로 전환되면, 다른 프로세스가 CPU를 할당받음

<br>

## 프로세스의 우선순위 처리 기법
여러가지 프로세스가 적절하게 cpu의 자원을 점유할 수 있게 하는 것이 참 중요하기 때문에 이에 따른 여러가지 스케줄링 기법이 존재한다.  

### 정적 우선순위 (Static Priority)
프로세스가 생성될 때 설정되며 실행 중에는 변경 되지 않는다! 실시간 시스템에서는 실시간 프로세스가 높은 우선순위를 가지도록 설정한다.

### 동적 우선순위 (Dynamic Priority)
- 프로세스의 실행 중에 우선순위가 변경될 수 있음
- 프로세스의 행동이나 시스템의 상태에 따라 조정
- 오래 대기한 프로세스의 우선순위를 높이거나, CPU 사용량이 많은 프로세스의 우선순위를 낮추는 방식.

<br>

## 프로세스 스케줄링
부여된 우선순위와 다양한 기준을 바탕으로 자원을 할당하는 전체적인 방법이다.  

### 스케줄링 종류
> A 프로세스가 CPU를 사용중 일때, B 프로세스가 급하다며 CPU 할당을 요구한다면?  

- **선점형 스케줄링**
  - A로부터 CPU의 자원을 빼앗아 B에게 할당
  - 특정 프로세스가 CPU를 독점할 수 없으며, 인터럽트에 따라 다음 프로세스에게 CPU 자원을 넘겨줌
  - CPU 자원 독점을 막고 골고루 배분이 가능하지만, 프로세스 context switch 과정에서 오버헤드 발생 가능
- **비선점형 스케줄링**
  - A의 작업이 다 끝날 때까지 대기
  - 한 프로세스의 CPU 독점 사용을 의미
  - 프로세스 context switch 과정에서 오버헤드 가능성이 적지만, 응답 시간 지연, 기아 문제, 자원 효율성 저하 등의 문제 발생

<br>

## 스레드
스레드는, 실행 흐름의 단위이다! 스레드를 설명할 때 가장 많이 듣는 말이지만 처음부터 마음 속으로 와닿지는 않는 표현이다... 프로세스와 달리 스레드는 같은 주소 공간을 공유하고, 또한 각 스레드만의 스택과 레지스터, TCB를 가지고 있다. 스레드를 통해 병렬처리, 자원공유가 가능하며 이를 통해 메모리 사용을 효율화할 수 있다! (스레드 또한 프로세스와 같이 cpu 자원 점유를 위해 노력한다.생성-준비-실행-대기-종료 등)  

이때 **TCB**란, 스레드 Thread Control Block을 의미하며 PCB와 유사하지만, 스레드 고유만의 정보를 담고 있는 자료구조이다.  

<br>

## 스레드 간의 자원 공유
그렇다면 스레드 간의 자원 공유는 어떻게 일어날까? 철학자 과제에서 가장 중요한 것은 각각의 독립된 스레드로 이루어진 철학자들이 공유자원에 속한 포크를 적절하게 순서에 맞추어 나눠 사용하는 것이다. 즉 스레드가 자원공유 하는 과정에서 데이터 레이스가 일어나지 않도록 해야하고, 특정 스레드가 자원을 계속해서 점유하거나 무한 경쟁하는 등의 상황을 피해야 한다.  

### 스레드 간 공유 자원
우선 스레드 간 어떤 자원들을 공유할 수 있는지 알아보자!  

1. **주소 공간 (Address Space)**
   - 모든 스레드는 동일한 프로세스의 주소 공간을 공유
   - 같은 코드, 데이터, 힙을 접근할 수 있음
   - 예를 들어, 하나의 스레드가 힙에 동적 메모리를 할당하면 다른 스레드도 이 메모리에 접근할 수 있음
2. **전역 변수 및 정적 변수 (Global and Static Variables)**
   - 스레드는 전역 변수와 정적 변수를 공유
   - 이는 여러 스레드가 동일한 변수를 읽고 쓸 수 있음을 의미
   - 이로 인해 여러 스레드가 동시에 변수에 접근할 경우 동기화 문제가 발생 가능
3. **파일 디스크립터 테이블 (File Descriptor Table)**
   - 파일 입출력을 위한 파일 디스크립터를 공유
   - 한 스레드가 파일을 열면 다른 스레드도 이 fd를 사용하여 파일에 접근 가능
4. **프로세스 환경 (프로세스 Environment)**
   - 프로세스 ID, 사용자 ID, 그룹 ID와 같은 프로세스 관련 정보는 모든 스레드가 공유

<br>

### 스레드간 비공유자원
우선 스레드 간 어떤 자원들을 공유할 수 없는지 알아보자!  

1. **스택 (Stack)**
   - 각 스레드는 고유한 스택을 가짐
   - 스택은 함수 호출, 로컬 변수, 함수 매개변수 등을 저장하는 데 사용
   - 스레드마다 독립적인 스택을 가지기 때문에, 하나의 스레드에서 발생한 스택 오버플로우는 다른 스레드에 영향을 미치지 않음
2. **레지스터 (Registers)**
   - CPU 레지스터는 스레드마다 고유함
   - 레지스터에는 프로그램 카운터, 스택 포인터, 일반 목적 레지스터 등이 포함
   - context switch 시, 각 스레드의 레지스터 상태를 저장하고 복원
3. **스레드 로컬 저장소**
   - 각 스레드는 스레드 로컬 변수를 가질 수 있음
   - 이는 스레드 간에 공유되지 않는 변수로, 스레드마다 독립적인 값을 가잠
   - 예를 들어, TLS를 사용하여 각 스레드가 자신의 고유한 데이터를 저장할 수 있음

## TLS란?
- 스레드 Local Storage
- 각 스레드가 독립적으로 값을 저장하고 접근할 수 있는 메모리 영역
- TLS는 스레드 간에 공유되지 않아야 할 데이터, 즉 스레드별로 독립적인 상태 정보를 유지해야 할 때 사용
- 이는 스레드가 시작될 때 생성되고, 스레드가 종료될 때 해제됨
-  멀티스레드 환경에서 데이터의 독립성을 유지하면서도 스레드별 상태 관리를 용이하게 해주며, 이를 통해 스레드는 자신만의 데이터를 안전하게 관리 가능

## TLS vs 스택 영역
### TLS
- 위치: TLS는 스택과는 별도의 메모리 영역에 위치
- 역할: 각 스레드마다 독립적인 변수를 저장하기 위한 용도로 사용
- 관리: 운영체제와 스레드 라이브러리가 관리
- 생성과 소멸: 스레드가 생성될 때 할당되고, 스레드가 종료될 때 해제
### 스택
- 위치: 각 스레드는 자신의 독립적인 스택 영역을 가짐
- 역할: 함수 호출, 지역 변수, 함수 매개변수 등을 저장하는 데 사용
- 관리: 스레드 자체에 의해 관리되며, 함수 호출 시 스택 프레임이 생성되고, 함수가 반환될 때 스택 프레임이 해제


<br>
<br>


<br>
<br>

# Reference
____
- https://man7.org/linux/man-pages/man2/read.2.html
- https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html
- https://code-lab1.tistory.com/65


https://thebook.io/080367/0021/


<br>
{{<alert>}}
<a href="https://elecbrandy.github.io/tags/42cursus"> 42cursus </a>
{{</alert>}}
<br>
